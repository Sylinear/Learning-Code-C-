#define _CRT_SECURE_NO_WARNINGS 1


/*
内存分区模型

    C++程序执行时，会将内存大方向划分为4个区域

    1.代码区 - 存放函数体的二进制代码 由操作系统进行管理
    2.全局区 - 存放①全局变量 ②静态变量 ③常量
    3.栈区   - 由编译器自动分配释放，存放函数的参数值、局部变量
    4.堆区   - 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

    内存四区的意义：不同区域存放的区域 赋予不同的生命周期 给予更大的灵活编程



程序运行前
    
    在程序编译后，生成了exe可执行程序，未执行该程序前就已存在两个区域：

    ①代码区
        存放CPU执行的机器指令(二进制)
        ―――― 代码区是共享的 目的是对于频繁被执行的程序 内存中只需要有一份代码即可
        ―――― 代码区是只读的 使其只读的原因是防止程序意外修改了它的指令

    ②全局区
        全局变量 和 静态变量 存放在此，同时还有常量区、字符串常量 和其他常量
        该区域的数据在程序结束后由操作系统释放
*/

#include<iostream>
using namespace std;
//
////全局区
//
////全局变量
//int g_a = 10;
//int g_b = 20;
//
////静态变量 - 在普通变量的前面加上static,属于静态变量
//static int s_a = 10;   //只能使用于该.cpp文件
//static int s_b = 20;   
//
////const修饰的全局变量
//const int c_g_a = 10;
//
//int main()
//{
//    //局部变量
//    int a = 10;
//    int b = 20;
//
//    //静态变量
//    static int s_c = 40;
//
//    //常量分为两种：字符串修饰的常量 / const修饰的变量
//    
//    //字符串常量
//    string c = "abcedf";
//
//    //const修饰的局部变量
//    const int c_l_b = 20;       // c-const g-global l-local
//
//
//
//
//    cout << "局部变量a的地址:" << &a << endl;
//    cout << "局部变量b的地址:" << &b << endl;
//        //-存放于栈区
//    
//    
//    cout << "全局变量g_a的地址:" << &g_a << endl;
//    cout << "全局变量g_b的地址:" << &g_b << endl;
//        //-存放于全局区
//
//    cout << "静态变量s_a的地址：" << &s_a << endl;
//    cout << "静态变量s_b的地址：" << &s_b << endl;
//    cout << "静态变量s_c的地址：" << &s_c << endl;
//        //存放于全局区
//
//
//    cout << "字符串常量的地址是：" << &("hello world") << endl;
//        //-存放于全局区
//    cout << "字符串变量c的地址是：" << &c << endl;
//        //-存放于栈区
//
//
//    cout << "全局常量c_g_a地址是：" << &c_g_a << endl;
//        //-存放于全局区
//    cout << "局部常量c_l_b地址是：" << &c_l_b << endl;
//        //-存放于栈区
//
//
//    return 0;
//}

////运行前 ：  有全局区 代码区
//    //代码区 - 共享和只读 
//    //全局区 - 存放全局变量 静态变量 常量区
//                                    //常量区包括 const修饰的全局常量 字符串常量
//                                                //局部变量 局部常量 均不在常量区



/*
程序运行后：
    
    栈区：
        编译器自动释放，存放函数的参数值(形参)、局部变量等
        【【【【注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放】】】

*/

//int* func( int b )//形参数据也存放在栈区
//{
//    b = 100; 
//    int a = 10;//局部变量
//    return &a; //返回局部变量的地址
//}
//
//int main()
//{
//    int* p = func();
//    cout << *p << endl;//结果是10
//    cout << *p << endl;//结果是随机值
//    //因为a是func函数内的局部变量 当执行完后 栈的数据就被清空了 因此会访问到乱码 此时p属于野指针
//        //第一次能得到正确的数据 是因为VS编译器给使用者进行了保留 在别的编译器甚至会直接报错
//
//    return 0;
//}



/*

    堆区：
        由程序员分配，程序结束时由操作系统回收
            在C时 用malloc calloc realloc进行开辟 用free进行释放 
            而在C++中则主要使用new进行开辟 delete进行释放

*/
//new  与  delete
int* func()
{
    //利用new关键字 可以将数据开辟到堆区
    int* p0 = new int(10);
        //new关键字原则 new + 类型种类(数值)  返回的是该数据的地址
    //如：
    char* p1 = new char('a');

    return p0;
}

//1.new的基本语法：
int* func1()
{
        //在堆区创建整型数据
        //new返回的 是该数据类型的指针

    int* a = new int(20);
    double* b = new double(3.14);

    return a;
}

void test01()
{
    int* p = func1();
    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;
    //堆区中的内容不会被编译器释放 需要程序员管理释放 使用关键字delete
    delete p;
}

//2.如何在堆区开辟一个数组呢？
void test02()
{
    int* arr = new int[10];//将()改为[]即可
    int* arr1 = new int[6]{ 6, 5, 4, 3, 2, 1 };//在[]后紧跟{}即可初始化数组 不初始化默认为0
    //int arr2[10] = new int[10];//不能用int[] char[]形式来接收new的地址

    for (int i = 0; i < 10; i++)
    {
        arr[i] = 10 * i;
    }
    for (int i = 0; i < 10; i++)
    {
        cout << arr[i] << endl;
    }

    //【【【【【注意】】】】】】 delete数组时 也要加[]     ; 若不加[] 则只会释放数组第一个元素
    delete[] arr;

}

int main()
{

    int* p = func();

    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;
    //【【【注意】】】：func中创建的指针p0是局部变量 的确在栈区 在退出程序时即销毁了 因此p依旧是危险的野指针 不要使用！ 
                            //但p0储存的数据保存在堆区 并没有被销毁


    delete p;//使用delete语句 可以将指针对应的堆区空间进行释放
    //cout << *p << endl;//无法访问 因为空间已释放


    test01();


    test02();
    

    return 0;
}
#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;

/*
*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。
*/

//构造函数 和 析构函数
    //对象的初始化和清理十分重要:
        //初始化:一个对象或者变量没有初始状态，对其使用后果是未知
        //清理:同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

    //C++使用构造函数来进行初始化 使用析构函数来清理变量 这两个函数会被编译器自动调用(哪怕你没写) 完成对象初始化和清理
        //但我们不提供构造和析构时 编译器提供的构造函数和析构函数是空实现

//构造函数：主要作用在于[创建对象时]为对象的[成员属性]赋值，构造函数由编译器自动调用，无须手动调用。
//析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。



//对象的初始化和清理
    //1. 构造函数 进行初始化操作
    //2. 析构函数 进行清理操作

//构造函数 的语法:
    //  类名() {}
      // 注:1.构造函数 不需要返回值 连void也不用写
          // 2.函数名不用写 函数名与类名相同
           // 3.构造函数会在调用对象的时候自动构造 无需手动调用 而且只会调用一次
             // 4.构造函数可以有参数 因此可以发生重载  (可以有初始值)

//析构函数 的语法:
    //  ~类名() {}
      // 注:1.同样不需返回值
          // 2. 名称在类名前加上~
           // 3. 不可以有参数 因此不可重载      (删除数据你重载什么重载)
            // 4. 程序会在对象销毁前自动调用析构 无需手动调用 且只有一次

//class Person
//{
//public:
//    //构造函数
//    Person() 
//    {
//        cout << "构造函数的调用" << endl;
//    };            //没有返回值 也不用写void  函数名就是类名  实例化对象时会自动调用 且只调用一次
//
//    //析构函数
//    ~Person()
//    {
//        cout << "析构函数的调用" << endl;
//    }
//};
//
//void test01()
//{
//    Person P;
//}
//int main()
//{
//    test01();//可以发现 只是创建对象时 构造函数就自动调用了 且只调用一次 
//                //若我们不自己写 编译器也会自动创建构造函数 但是空函数  
//             
//             //析构函数也调用了 局部变量位于栈 因为程序结束时 栈上的数据就会被释放 因此调用了析构函数
//
//    Person P1;//构造函数调用了 
//                //但析构函数没有立刻调用 在执行了"pause"之后才调用 因为对象P1作用域为主函数 在main函数结束后才释放数据
//
//    system("pause");
//    return 0;
//}





//构造函数的分类和调用
/*
两种分类方式：
    按参数：  有参构造   和   无参构造
    按类型：  普通构造   和   拷贝构造

三种调用方法：
    1.括号法
    2.显示法
    3.隐式转换法
*/
//构造函数分类
//class Person
//{
//public:
//    //构造函数
//    Person()    //没有参数的构造函数 称为无参构造 也称为[默认构造函数] 编译器默认提供的就是无参的
//    {
//        cout << "Person的构造" << endl;;
//    }
//    Person(int a)    //有参数的构造函数 称为有参构造 当带有参数时会调用该函数
//    {
//        m_age = a;
//        cout << "Person(int a)的构造" << endl;;
//    }
//
//    //以上几个 都属于普通构造函数
//    //接下来是拷贝构造函数
//    Person(const Person &p) //拷贝:把原本的对象 复制一份拷贝--->因此传入的参数是一个实例化对象
//                                    //①不能修改本体 因此要加const
//                                        //②使用[引用传参] 因此写成 Person &p
//    {
//        m_age = p.m_age;//将对象p原本的所有属性 拷贝到新对象中
//        cout << "拷贝构造" << endl;
//    }
//
//public:
//    int m_age;
//
//};
//
////调用构造
//void test01()
//{
//    //1.括号法
//    Person P1;//默认构造调用(无参构造)       
//    Person P2(10);//有参构造调用
//
//    Person P3(P2);//拷贝构造调用  此时构造参数是另一个对象
//    cout << "P2的年龄为:" << P2.m_age << endl;
//    cout << "P3的年龄为:" << P3.m_age << endl; //可见 P3的参数与P2是一致的
//
//
//        //*******注意 调用无参构造时 不要加括号***********
//        Person P4();//无反应 因为此时编译器认为你写的是一个函数的声明 而并不是进行默认构造
//}
//void test02()
//{
//    //2.显式法       
//    Person p1;
//    Person p2 = Person(10);//显式法 有参构造
//    Person p3 = Person(p2);//显式法 拷贝构造
//        //可见 显式法是把[Person]充当函数名 来调用 并把结果赋给新对象
//
//    Person(10);//*匿名对象 没有实例化对象的名称  特点:当前行执行结束后,系统会立即回收掉匿名对象.
//            
//               
//        //*******注意 不用利用拷贝构造函数 初始化匿名对象***********
//        Person(p3); //用拷贝构造 初始化匿名对象 
//                //编译器报错重定义  因为编译器会认为 Person(p3) === Person p3;
//                                              //编译器认为你是在创建一个名为p3的对象
//}
//void test03()
//{
//    //3.隐式转换法
//
//    Person p4 = 10;//有参构造  相当于写了Person p4 = Person(10);
//    Person p5 = Person(10);//两条式子等价
//
//    Person p6 = p4;//拷贝构造 等价于Person p6 = Person(p4);
//
//}
//int main()
//{
//    test01();
//    return 0;
//}







//拷贝构造函数调用时机
/*
    同时有三种情况需要调用拷贝构造函数:
        1.使用一个已经创建完毕的对象来初始化一个新对象 -> 拷贝一个新对象
        2.值传递的方式给函数参数传参                 -> 调用函数 使用[值传递]调用对象时 会进行拷贝构造
        3.以值方式返回局部对象                      -> 返回值为一个局部对象 此时会进行拷贝构造
*/
//class Person
//{
//public:
//    Person()
//    {
//        cout << "默认构造" << endl;
//    }
//    Person(int age)
//    {
//        m_age = age;
//        cout << "有参构造" << endl;
//    }
//    Person(const Person& p)
//    {
//        m_age = p.m_age;
//        cout << "拷贝构造" << endl;
//    }
//    ~Person()
//    {
//        cout << "析构" << endl;
//    }
//
//    int m_age;
//};
//void test01()
//{
//  //1.使用一个已经创建完毕的对象来初始化一个新对象
//    Person p1(20);//有参构造
//    Person p2(p1);//拷贝构造
//
//    cout << "p2的年龄为:" << p2.m_age << endl;
//
//    Person p3;
//    p3 = p2;//需要注意  "Person p3 = p2;" 和 "p3 = p2;"这两条并不相同 前者是拷贝 而后者只是单纯的赋值
//    cout << "p3的年龄为:" << p3.m_age << endl;
//}
//
//  //2.值传递的方式给函数参数传参
//void test02(Person p)   //传值调用 参数为对象  触发构造(引用和传址则不会)
//{
//
//}
//
//  //3.以值方式返回局部对象
//Person test03()
//{
//    Person p1(5);
//    cout << &p1 << endl;
//    return p1; //返回值为对象 会进行一次拷贝 并将拷贝值传到外界
//}
//int main()
//{
//    test01();
//
//    //Person p0(10);
//    //test02(p0);//可见在传参时 进行了一次拷贝构造
//
//    //Person p4 = test03();//可见此处是进行了一次拷贝构造
//    //cout << &p4 << endl;    //函数内的p1和外部的p4的地址并不相同 意味着不是同一个对象
//
//    //test03();//若没有接受该返回值 则是匿名构造 该行结束直接析构
//
//    system("pause");
//    return 0;
//}






//构造函数调用规则
/*
默认情况下,我们一旦创建一个类,C++编译器就会立刻添加三个函数:

    1.默认构造函数 (无参 函数体为空)

    2.默认析构函数 (无参 函数体为空)

    3.默认拷贝构造函数,对属性进行值拷贝 (值拷贝)

 
构造函数调用规则如下:
    1.如果用户定义了[有参构造] ,则C++不再提供默认构造函数,以用户的函数优先级为先.但依然提供拷贝函数
 
    2.如果用户定义了[拷贝构造] ,则c++不再提供其他构造函数

*/
//class Person 
//{
//public:
//    Person()//默认构造
//    {
//        cout << "默认构造" << endl;
//    }
//
//    Person(int age)//有参构造
//    {
//        m_Age = age;
//        cout << "有参构造" << endl;
//    }
//
//    //Person(const Person& p)//拷贝构造
//    //{
//    //    m_Age = p.m_Age;
//    //    cout << "拷贝构造" << endl;
//    //}
//
//    ~Person()//析构
//    {
//        cout << "析构" << endl;
//    }
//
//    int m_Age;
//
//};
//
//class Person01  //定义[有参构造]  则编译器不提供默认构造 但依然提供拷贝构造
//{
//public:
//    //Person01()//默认构造
//    //{
//    //    cout << "01默认构造" << endl;
//    //}
//
//    Person01(int age)//有参构造
//    {
//        m_Age = age;
//        cout << "01有参构造" << endl;
//    }
//
//    //Person(const Person& p)//拷贝构造
//    //{
//    //    m_Age = p.m_Age;
//    //    cout << "01拷贝构造" << endl;
//    //}
//
//    ~Person01()//析构
//    {
//        cout << "01析构" << endl;
//    }
//
//    int m_Age;
//
//};
//
//class Person02  //定义[拷贝构造] 则编译器不提供任何默认构造
//{
//public:
//    //Person02()//默认构造
//    //{
//    //    cout << "01默认构造" << endl;
//    //}
//
//    //Person02(int age)//有参构造
//    //{
//    //    m_Age = age;
//    //    cout << "01有参构造" << endl;
//    //}
//
//    Person02(const Person& p)//拷贝构造
//    {
//        m_Age = p.m_Age;
//        cout << "02拷贝构造" << endl;
//    }
//
//    ~Person02()//析构
//    {
//        cout << "02析构" << endl;
//    }
//
//    int m_Age;
//
//};
//int main()
//{
//    Person p;
//    p.m_Age = 10;
//
//    Person p2(p);//拷贝构造 
//    cout << "p2的年龄为:" << p2.m_Age << endl;
//    //屏蔽了我们写的拷贝构造,再调用一次
//        //发现p2中的年龄依然为10了 这是因为编译器默认会给我们一个拷贝构造 进行值拷贝
//            //因此记住 编译器会默认给我们拷贝构造
//
//    //1.如果用户定义了 有参构造, 则C++不再提供默认构造函数, 但依然会提供拷贝函数
//        //Person01 p1;
//            //报错了
//                //我们定义了有参构造 但是没有定义默认构造 此时可见无法进行无参构造了!
//                        //因此 若要定义有参构造 必须同时准备好其他构造
//        
//        Person01 p1(10);
//        Person01 p3 = p1;//可见默认拷贝构造是可用的
//
//
//    //2.如果用户定义了[拷贝构造], 则c++不再提供其他构造函数
//        Person02 p4;
//                //报错 不存在默认构造
//
//    return 0;
//}







//深拷贝 与 浅拷贝
/*

    浅拷贝:简单的赋值拷贝操作 (普通的等号赋值操作 编译器默认给予的就是浅拷贝)

    深拷贝:在堆区重新申请空间,进行拷贝操作

*/
//class Person
//{
//public:
//    Person()
//    {
//        cout<<"构造"<<endl;
//    }
//
//    Person(int age ,int height)
//    {
//        m_age = age;
//        cout << "有参构造" << endl;
//
//        m_Height = new int(height);//在堆区new一个整型 并将地址赋给m_Height
//    }
//
//    //使用默认拷贝构造
//
//    ~Person()
//    {
//        //析构时,同时将堆区开辟的数据进行释放!
//        if (m_Height != NULL)
//        {
//            delete m_Height;
//            m_Height = NULL;//释放并置空
//        }
//        cout << "析构" << endl;;
//    }
//
//    int m_age;//年龄
//    int* m_Height; //身高  -- 且要求该数据开辟到堆区
//};
//
////实现深拷贝构造函数 解决浅拷贝带来的问题
//class Person01
//{
//public:
//    Person01()
//    {
//        cout << "构造" << endl;
//    }
//
//    Person01(int age, int height)
//    {
//        m_age = age;
//        cout << "有参构造" << endl;
//
//        m_Height = new int(height);//在堆区new一个整型 并将地址赋给m_Height
//    }
//
//    //深拷贝 
//    Person01(const Person01 &p)
//    {
//        cout << "拷贝构造" << endl;
//        m_age = p.m_age;
//        //m_Height = p.m_Height; //编译器默认实现的就是这行代码
//        //深拷贝操作
//        m_Height = new int(*p.m_Height);
//    }
//
//    ~Person01()
//    {
//        //析构时,同时将堆区开辟的数据进行释放!
//        if (m_Height != NULL)
//        {
//            delete m_Height;
//            m_Height = NULL;//释放并置空
//        }
//        cout << "析构" << endl;;
//    }
//
//    int m_age;//年龄
//    int* m_Height; //身高  -- 且要求该数据开辟到堆区
//};
//void test01()
//{
//    Person p1(18, 160);
//    cout << "p1的年龄为:" << p1.m_age << "\tp1的身高为:" << *p1.m_Height << endl;
//
//    Person p2(p1);
//    cout << "p2的年龄为:" << p2.m_age << "\tp2的身高为:" << *p2.m_Height << endl;
//            //编译器默认帮我们写的浅拷贝 是直接值传递 使用的数据是直接传递过去的 会导致问题:
//    
//    
//    //问题1 -- 重复释放
//        //编译器报错了  原因是:p1析构时 m_Height指向的堆区空间已被释放,且p1.m_Height已置空
//                                //但p2.m_Height未被置空 依然保留了那个地址 从而导致了重复释放的问题!
//
//    //问题2 -- 内存复用
//        *p1.m_Height = 180; //修改p1
//        cout << "p2的年龄为:" << p2.m_age << "\tp2的身高为:" << *p2.m_Height << endl;//查看p2
//          //可见 当我们修改p1中堆区存放的身高时 p2显示的身高也随之修改了!
//            //这是因为浅拷贝中 直接让p2.m_Height = p1.m_Height 因此他们两个指向的是堆区中的同一块地址!
//
//    //解决方法:  --> 深拷贝    除了赋值外 在调用拷贝时 在堆区另外开辟一块新的内存
//
//}
//
//void test02()
//{
//    Person01 p1(18, 160);
//    cout << "p1的年龄为:" << p1.m_age << "\tp1的身高为:" << *p1.m_Height << endl;
//
//    Person01 p2(p1);
//    cout << "p2的年龄为:" << p2.m_age << "\tp2的身高为:" << *p2.m_Height << endl;
//
//    *p1.m_Height = 180; //修改p1
//    cout << "p2的年龄为:" << p2.m_age << "\tp2的身高为:" << *p2.m_Height << endl;//查看p2
//}
//int main()
//{
//    //test01();
//
//    test02();//使用深拷贝 解决所有问题
//
//    return 0;
//}






//初始化列表
/*
    使用初始化列表 来初始化属性

    语法: 构造函数(): 属性1(值1) , 属性2(值2) ... {}

*/
//class Person01
//{
//public:
//    //传统初始化操作
//    Person01(int a, int b, int c)
//    {
//        m_A = a;
//        m_B = b;
//        m_C = c;
//    }
//
//    int m_A;
//    int m_B;
//    int m_C;
//};
//
//class Person02
//{
//public:
//    //初始化列表初始化属性
//    Person02() : m_A(10), m_B(20), m_C(30) 
//    {}
//    
//    //重载
//    Person02(int a, int b, int c) : m_A(a), m_B(b), m_C(c) 
//    {}
//
//    int m_A;
//    int m_B;
//    int m_C;
//};
//void test01()
//{
//    Person01 p1(10,20,30);
//    cout << "p1: m_A = " << p1.m_A << "  m_B = " << p1.m_B << "  m_C = " << p1.m_C << endl;
//
//    Person02 p2;//初始化列表 进行 初始化赋值
//    cout << "p2: m_A = " << p2.m_A << "  m_B = " << p2.m_B << "  m_C = " << p2.m_C << endl;
//
//    Person02 p3(30, 20, 10);
//    cout << "p3: m_A = " << p3.m_A << "  m_B = " << p3.m_B << "  m_C = " << p3.m_C << endl;
//}
//int main()
//{
//    test01();
//    return 0;
//}







//类对象作为类的成员
class A{};
class B
{
    A a; //类B中含有 对象成员A
};
    //问题: 是先构造B 还是先构造A?

class Phone //手机类
{
public:
    Phone(string pName)//有参构造
    {
        m_pName = pName;
        cout << "Phone的构造" << endl;
    }

    ~Phone()
    {
        cout << "Phone的析构" << endl;
    }
    string m_pName;
};

class Person //人类
{
public:
    Person(string name, string pName) :m_Name(name), m_Phone(pName)//使用初始化列表
    {                                                   //↑注意此处的语法 并不需要写.m_pName
        cout << "Person的构造" << endl;                    //因为此处会调用一次Phone的析构函数 完成赋值
    }                                                  //等价于:Phone m_Phone = pName;
                                                         //↑隐式转换法 即等同于 Phone m_Phone(pName);
    ~Person()
    {
        cout << "Person的析构" << endl;
    }
    //姓名
    string m_Name;
    //手机
    Phone m_Phone;
};

void test01()
{
    Person p("张三", "苹果MAX");
}
int main()
{
    test01();//可以发现实例化对象时 从内向外构造 从外向内析构

    return 0;
}